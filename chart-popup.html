<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üìä MDF Data Visualization_Jeongho Kwon</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
            color: #333;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: white;
            padding: 15px 20px;
            border-bottom: 1px solid #e9ecef;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .header h1 {
            color: #2c3e50;
            font-size: 1.3em;
            margin-bottom: 5px;
        }

        .header p {
            color: #6c757d;
            font-size: 0.9em;
        }

        .chart-container {
            flex: 1;
            padding: 20px;
        }

        #chartDiv {
            width: 100%;
            height: 100%;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            color: #666;
            font-size: 16px;
        }

        .loading::after {
            content: '';
            display: inline-block;
            width: 20px;
            height: 20px;
            margin-left: 10px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            color: #dc3545;
            font-size: 16px;
            text-align: center;
            padding: 20px;
        }

        .controls {
            background: white;
            padding: 15px 20px;
            border-top: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .channel-info {
            font-size: 0.9em;
            color: #6c757d;
        }

        .chart-controls button {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 0.9em;
            cursor: pointer;
            margin-left: 10px;
        }

        .chart-controls button:hover {
            background: #2980b9;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üìä MDF Data Visualization_Jeongho Kwon</h1>
        <p id="headerInfo">Real-time measurement data visualization</p>
    </div>

    <div class="chart-container">
        <div id="chartDiv">
            <div class="loading">Loading chart data...</div>
        </div>
    </div>

    <div class="controls">
        <div class="channel-info">
            <span id="channelInfo">No channels selected</span>
        </div>
        <div class="chart-controls">
            <button onclick="resetZoom()">üîç Reset Zoom</button>
            <button onclick="exportChart()">üíæ Export PNG</button>
            <button onclick="window.close()">‚úñÔ∏è Close</button>
        </div>
    </div>

    <script>
        // Ï∞®Ìä∏ Í¥ÄÎ†® Ï†ÑÏó≠ Î≥ÄÏàò
        let chartData = null;
        let channelNames = [];

        // URL Îß§Í∞úÎ≥ÄÏàòÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
        function getUrlParams() {
            const urlParams = new URLSearchParams(window.location.search);
            const sessionId = urlParams.get('sessionId');
            const channels = urlParams.get('channels');
            const chartType = urlParams.get('chartType') || 'single';
            
            if (channels) {
                channelNames = JSON.parse(decodeURIComponent(channels));
            }
            
            return { sessionId, channelNames, chartType };
        }

        // Î∞±ÏóîÎìúÏóêÏÑú Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
        async function fetchChartData(sessionId, channelNames) {
            try {
                const response = await fetch(`http://localhost:8000/api/data/${sessionId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(channelNames)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || 'Failed to fetch channel data');
                }

                const data = await response.json();
                return data.data; // Ï±ÑÎÑê Îç∞Ïù¥ÌÑ∞ Î∞∞Ïó¥ Î∞òÌôò
                
            } catch (error) {
                console.error('Error fetching chart data:', error);
                throw error;
            }
        }

        // Ï∞®Ìä∏ ÏÉùÏÑ±
        function createChart(channelData, chartType) {
            if (chartType === 'multiple') {
                createMultipleCharts(channelData);
            } else {
                createSingleChart(channelData);
            }
            
            // Ï∞®Ìä∏ Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
            updateChartInfo(channelData);
        }

        // Îã®Ïùº Ï∞®Ìä∏ ÏÉùÏÑ±
        function createSingleChart(channelData) {
            const traces = channelData.map((data, index) => {
                // Îã®ÏúÑ Ï†ïÎ≥¥Î•º Ìè¨Ìï®Ìïú Ïù¥Î¶Ñ ÏÉùÏÑ±
                const displayName = data.unit ? `${data.name} (${data.unit})` : data.name;
                
                return {
                    x: data.timestamps,
                    y: data.values,
                    name: displayName,
                    type: 'scatter',
                    mode: 'lines',
                    line: {
                        width: 2
                    },
                    hovertemplate: `<b>${displayName}</b><br>` +
                                  `Time: %{x:.3f} s<br>` +
                                  `Value: %{y:.6f}<br>` +
                                  `<extra></extra>`
                };
            });

            const layout = {
                title: {
                    text: 'MDF Measurement Data - Combined View_Jeongho Kwon',
                    font: { 
                        size: 18,
                        color: '#2c3e50'
                    }
                },
                xaxis: {
                    title: {
                        text: 'Time (seconds)',
                        font: { size: 14 }
                    },
                    gridcolor: '#f0f0f0',
                    showgrid: true
                },
                yaxis: {
                    title: {
                        text: 'Measurement Value',
                        font: { size: 14 }
                    },
                    gridcolor: '#f0f0f0',
                    showgrid: true
                },
                plot_bgcolor: 'white',
                paper_bgcolor: 'white',
                margin: { t: 60, r: 40, b: 120, l: 80 },
                legend: {
                    orientation: 'h',
                    x: 0.5,
                    y: -0.15,
                    xanchor: 'center',
                    yanchor: 'top',
                    bgcolor: 'rgba(255,255,255,0.9)',
                    bordercolor: '#E2E2E2',
                    borderwidth: 1,
                    font: { size: 10 }
                },
                hovermode: 'x unified',
                showlegend: true
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                displaylogo: false,
                toImageButtonOptions: {
                    format: 'png',
                    filename: 'mdf_single_chart',
                    height: 600,
                    width: 1000,
                    scale: 2
                }
            };

            Plotly.newPlot('chartDiv', traces, layout, config);
        }

        // Î≥µÏàò Ï∞®Ìä∏ ÏÉùÏÑ±
        function createMultipleCharts(channelData) {
            const chartDiv = document.getElementById('chartDiv');
            chartDiv.innerHTML = '';
            
            const numChannels = channelData.length;
            const cols = Math.ceil(Math.sqrt(numChannels));
            const rows = Math.ceil(numChannels / cols);
            
            chartDiv.style.display = 'grid';
            chartDiv.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            chartDiv.style.gridTemplateRows = `repeat(${rows}, 1fr)`;
            chartDiv.style.gap = '10px';
            chartDiv.style.padding = '10px';

            channelData.forEach((data, index) => {
                const subDiv = document.createElement('div');
                subDiv.id = `chart-${index}`;
                subDiv.style.minHeight = '300px';
                subDiv.style.background = 'white';
                subDiv.style.borderRadius = '5px';
                subDiv.style.border = '1px solid #e0e0e0';
                chartDiv.appendChild(subDiv);

                const displayName = data.unit ? `${data.name} (${data.unit})` : data.name;
                
                const trace = {
                    x: data.timestamps,
                    y: data.values,
                    name: displayName,
                    type: 'scatter',
                    mode: 'lines',
                    line: {
                        width: 2,
                        color: `hsl(${(index * 137.5) % 360}, 70%, 50%)`
                    },
                    hovertemplate: `<b>${displayName}</b><br>` +
                                  `Time: %{x:.3f} s<br>` +
                                  `Value: %{y:.6f}<br>` +
                                  `<extra></extra>`
                };

                const layout = {
                    title: {
                        text: displayName,
                        font: { 
                            size: 14,
                            color: '#2c3e50'
                        }
                    },
                    xaxis: {
                        title: {
                            text: 'Time (s)',
                            font: { size: 10 }
                        },
                        gridcolor: '#f0f0f0',
                        showgrid: true,
                        tickfont: { size: 9 }
                    },
                    yaxis: {
                        title: {
                            text: data.unit || 'Value',
                            font: { size: 10 }
                        },
                        gridcolor: '#f0f0f0',
                        showgrid: true,
                        tickfont: { size: 9 }
                    },
                    plot_bgcolor: 'white',
                    paper_bgcolor: 'white',
                    margin: { t: 40, r: 20, b: 50, l: 50 },
                    legend: {
                        orientation: 'h',
                        x: 0.5,
                        y: -0.2,
                        xanchor: 'center',
                        yanchor: 'top',
                        bgcolor: 'rgba(255,255,255,0.9)',
                        bordercolor: '#E2E2E2',
                        borderwidth: 1,
                        font: { size: 8 }
                    },
                    showlegend: true,
                    hovermode: 'x'
                };

                const config = {
                    responsive: true,
                    displayModeBar: true,
                    modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                    displaylogo: false
                };

                Plotly.newPlot(subDiv.id, [trace], layout, config);
            });
        }

        // Ï∞®Ìä∏ Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
        function updateChartInfo(channelData) {
            const channelCount = channelData.length;
            const totalDataPoints = channelData.reduce((sum, data) => sum + data.values.length, 0);
            
            document.getElementById('headerInfo').textContent = 
                `${channelCount} channels ‚Ä¢ ${totalDataPoints.toLocaleString()} data points`;
            
            document.getElementById('channelInfo').textContent = 
                `Channels: ${channelNames.join(', ')}`;
        }

        // Ï§å Î¶¨ÏÖã
        function resetZoom() {
            const chartDiv = document.getElementById('chartDiv');
            
            // Îã®Ïùº Ï∞®Ìä∏Ïù∏ Í≤ΩÏö∞
            if (chartDiv.data) {
                Plotly.relayout('chartDiv', {
                    'xaxis.autorange': true,
                    'yaxis.autorange': true
                });
            } else {
                // Î≥µÏàò Ï∞®Ìä∏Ïù∏ Í≤ΩÏö∞
                const subCharts = chartDiv.querySelectorAll('[id^="chart-"]');
                subCharts.forEach(subChart => {
                    if (subChart.data) {
                        Plotly.relayout(subChart.id, {
                            'xaxis.autorange': true,
                            'yaxis.autorange': true
                        });
                    }
                });
            }
        }

        // Ï∞®Ìä∏ ÎÇ¥Î≥¥ÎÇ¥Í∏∞
        function exportChart() {
            const chartDiv = document.getElementById('chartDiv');
            
            // Îã®Ïùº Ï∞®Ìä∏Ïù∏ Í≤ΩÏö∞
            if (chartDiv.data) {
                Plotly.downloadImage('chartDiv', {
                    format: 'png',
                    filename: 'mdf_single_chart',
                    height: 600,
                    width: 1000,
                    scale: 2
                });
            } else {
                // Î≥µÏàò Ï∞®Ìä∏Ïù∏ Í≤ΩÏö∞ - Í∞Å Ï∞®Ìä∏Î•º Í∞úÎ≥ÑÏ†ÅÏúºÎ°ú ÎÇ¥Î≥¥ÎÇ¥Í∏∞
                const subCharts = chartDiv.querySelectorAll('[id^="chart-"]');
                subCharts.forEach((subChart, index) => {
                    if (subChart.data) {
                        const channelName = subChart.data[0].name.replace(/[^a-zA-Z0-9]/g, '_');
                        Plotly.downloadImage(subChart.id, {
                            format: 'png',
                            filename: `mdf_chart_${index + 1}_${channelName}`,
                            height: 400,
                            width: 600,
                            scale: 2
                        });
                    }
                });
            }
        }

        // ÏóêÎü¨ ÌëúÏãú
        function showError(message) {
            document.getElementById('chartDiv').innerHTML = 
                `<div class="error">‚ùå Error: ${message}</div>`;
        }

        // ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú Ïã§Ìñâ
        window.onload = async function() {
            try {
                const { sessionId, channelNames, chartType } = getUrlParams();
                
                if (!sessionId || !channelNames || channelNames.length === 0) {
                    throw new Error('Missing session ID or channel information');
                }

                const channelData = await fetchChartData(sessionId, channelNames);
                
                if (!channelData || channelData.length === 0) {
                    throw new Error('No data received from server');
                }

                createChart(channelData, chartType);
                
            } catch (error) {
                console.error('Chart initialization error:', error);
                showError(error.message);
            }
        };

        // Ï∞Ω ÌÅ¨Í∏∞ Î≥ÄÍ≤Ω Ïãú Ï∞®Ìä∏ ÌÅ¨Í∏∞ Ï°∞Ï†ï
        window.onresize = function() {
            if (document.getElementById('chartDiv').data) {
                Plotly.Plots.resize('chartDiv');
            }
        };
    </script>
</body>
</html>